Cene syntax:


To consume whitespace with a known wrap-up pattern:

- We match the text repeatedly against the following cases until no match is found:

- - If we get the text \' we invoke the nameless freestanding comment macro.

- - If we get the text [' we invoke the nameless bounded comment macro with a wrap-up pattern consisting of the text ] and then expect to read that pattern afterwards. If we can't, that's an error.

- - If we get the text (' we invoke the nameless bounded comment macro with a wrap-up pattern consisting of the text ) and then expect to read that pattern afterwards. If we can't, that's an error.

- - If we get the text /' we invoke the nameless bounded comment macro with a wrap-up pattern consisting of peeking the current wrap-up pattern and then expect to peek the current wrap-up pattern afterwards. If we can't, that's an error.

- - If we get a nonempty span of Unicode whitespace, we do nothing.

- We have finished consuming whitespace.


To read an optional identifier with a known wrap-up pattern:

- We consume whitespace.

- We match the text against the following cases:

- - (Note that the text \' [' (' and /' cannot be encountered since we already handled comments when we consumed whitespace.)

- - If we get the text \@ we invoke the nameless freestanding identifier macro. We've found that identifier.

- - If we get the text [@ we invoke the nameless bounded identifier macro with a wrap-up pattern consisting of the text ] and then expect to read that pattern afterwards. If we can't, that's an error. If we can, we've found that identifier.

- - If we get the text (@ we invoke the nameless bounded identifier macro with a wrap-up pattern consisting of the text ) and then expect to read that pattern afterwards. If we can't, that's an error. If we can, we've found that identifier.

- - If we get the text /@ we invoke the nameless bounded identifier macro with a wrap-up pattern consisting of peeking the current wrap-up pattern and then expect to peek the current wrap-up pattern afterwards. If we can't, that's an error. If we can, we've found that identifier.

- - If we get a nonempty span of non-whitespace text other than \ [ ] ( ) / : . and end-of-file that normalizes to be a valid identifier, then we've found an identifier with that normalized text. The way we check that text "normalizes to be a valid identifier" should roughly follow the Unicode identifier rules, but we allow - and decimal digits anywhere in an identifier.

- - Otherwise, we've found that there is no identifier here.


To read a mandatory identifier with a known wrap-up pattern:

- We read an optional identifier with the current wrap-up pattern. If we don't get one, that's an error.


To read a mandatory identifier prefix with a known wrap-up pattern:

- We read a mandatory identifier with the current wrap-up pattern. That's the result.

- Before we finish, we consume whitespace, and then we consume the text : if it's the next text available.


To read an optional DSL-expression of some macro DSL with a known wrap-up pattern:

- We read an optional identifier with the current wrap-up pattern. If we get one:

- - We invoke the glossary DSL-expression macro for the current macro DSL.

- Otherwise, we match the text against the following cases:

- - (Note that the text \' [' (' /' \@ [@ (@ and /@ cannot be encountered since we already tried to read an identifier.)

- - If we get the text \ we invoke the nameless freestanding DSL-expression macro for the current macro DSL. We've found that DSL-expression.

- - If we get the text [ we invoke the nameless bounded DSL-expression macro for the current macro DSL with a wrap-up pattern consisting of the text ] and then expect to read that pattern afterwards. If we can't, that's an error. If we can, we've found that DSL-expression.

- - If we get the text ( we invoke the nameless bounded DSL-expression macro for the current macro DSL with a wrap-up pattern consisting of the text ) and then expect to read that pattern afterwards. If we can't, that's an error. If we can, we've found that DSL-expression.

- - If we get the text / we invoke the nameless bounded DSL-expression macro for the current macro DSL with a wrap-up pattern consisting of peeking the current wrap-up pattern and then expect to peek the current wrap-up pattern afterwards. If we can't, that's an error. If we can, we've found that DSL-expression.

- - Otherwise, we've found that there is no DSL-expression here.


To read a mandatory DSL-expression of some macro DSL with a known wrap-up pattern:

- We read an optional DSL-expression of the current macro DSL with the current wrap-up pattern. If we don't get one, that's an error.


Usual macros for comments and identifiers:

- The nameless freestanding comment macro:

- - We match the text against the following cases:

- - - If we get the text . we read a mandatory identifier prefix with the current wrap-up pattern, and we invoke the named freestanding comment macro named after it with the current wrap-up pattern.

- - - Otherwise, we read and discard a line of Unicode text, up to but not including the line break or end-of-file.

- The nameless bounded comment macro:

- - We match the text against the following cases:

- - - If we get the text . we read a mandatory identifier prefix with the current wrap-up pattern, and we invoke the named bounded comment macro named after it with the current wrap-up pattern.

- - - If we get the text < > or = that's an error. (See "NOTE HYPERSNIPPETS" below.)

- - - Otherwise, that's an error. (In the future, we might have this case read some text with maching brackets and ignore it all, or something like that.)

- The nameless freestanding identifier macro:

- - We match the text against the following cases:

- - - If we get the text . we read a mandatory identifier prefix with the current wrap-up pattern, and we invoke the named freestanding identifier macro named after it with the current wrap-up pattern.

- - - Otherwise, that's an error. (In the future, we might come up with something to do here.)

- The nameless bounded identifier macro:

- - We match the text against the following cases:

- - - If we get the text . we read a mandatory identifier prefix with the current wrap-up pattern, and we invoke the named bounded identifier macro named after it with the current wrap-up pattern.

- - - If we get the text < > or = that's an error. (See "NOTE HYPERSNIPPETS" below.)

- - - Otherwise, that's an error. (In the future, we might have this case read some text according to a whitespace-normalizing string DSL and use that as the identifier name, or something like that.)


Usual macros for most macro DSLs:

- The glossary DSL-expression macro:

- - We invoke the unceremonious DSL-expression macro for the current macro DSL for the given identifier.

- The nameless freestanding DSL-expression macro:

- - We match the text against the following cases:

- - - If we get the text ' or @ it's an error. (The only way we can get these is if the macro isn't invoked by the "read an optional DSL-expression" logic, which first attempts to read an identifier (ruling out the @ sigil for identifiers), which first attempts to consume whitespace (ruling out the ' sigil for comments). It doesn't seem important yet to cater to other ways of invoking one of these macros, so we simply treat this as an error.)

- - - If we get the text . we read a mandatory identifier prefix with the current wrap-up pattern, and we invoke the named freestanding DSL-expression macro named after it for the current macro DSL with the current wrap-up pattern.

- - - Otherwise, the behavior may vary according to the macro DSL. A few common behaviors are as follows:

- - - - It's an error. This is the usual behavior when there's likely going to be a single named freestanding macro that will be most prominent but we don't know what it is yet.

- - - - We proceed as though we got the text . anyway. This is the usual behavior when invoking several different named freestanding macros _is_ the most common thing to do.

- - - - We emulate a behavior similar to having no macro call at all, where the \ that originally started this freestanding macro call is instead reinterpreted as miscellaneous text (e.g. an identifier). This may be the usual behavior in certain string literal DSLs where \ is expected to occur often in the string data.

- The nameless bounded DSL-expression macro:

- - We match the text against the following cases:

- - - If we get the text ' or @ it's an error. (The only way we can get these is if the macro isn't invoked by the "read an optional DSL-expression" logic, which first attempts to read an identifier (ruling out the @ sigil for identifiers), which first attempts to consume whitespace (ruling out the ' sigil for comments). It doesn't seem important yet to cater to other ways of invoking one of these macros, so we simply treat this as an error.)

- - - If we get the text . we read a mandatory identifier prefix with the current wrap-up pattern, and we invoke the named bounded DSL-expression macro named after it for the current macro DSL with the current wrap-up pattern.

- - - If we get the text < > or = that's an error. (See "NOTE HYPERSNIPPETS" below.)

- - - Otherwise, the behavior may vary according to the macro DSL. A few common behaviors are as follows:

- - - - It's an error. This is the usual behavior when there's likely going to be a single named bounded macro that will be most prominent but we don't know what it is yet.

- - - - We proceed as though we got the text . anyway. This is the usual behavior when invoking several different named bounded macros _is_ the most common thing to do.

- - - - We emulate a behavior similar to having no macro call at all, where the [ ] ( ) and/or / that originally delimited this bounded macro call are instead interpreted as miscellaneous text (e.g. identifiers). This may be the usual behavior in certain string literal DSLs where matched sets of [ ] ( ) and / are expected to occur often in the string data.


Specific macro DSLs:

- In some sense, comments. However, these use the sigil ' and we treat them as a special case.

- - As described above, if the nameless freestanding comment macro doesn't find its . we read and discard a line of Unicode text, up to but not including the line break or end-of-file.

- - As described above, if the nameless bounded comment macro doesn't find its . that's an error.

- In some sense, identifiers. However, these use the sigil @ and we treat them as a special case.

- - As described above, if the nameless freestanding identifier macro doesn't find its . that's an error.

- - As described above, if the nameless bounded identifier macro doesn't find its . that's an error.

- Sink expressions: Expressions that evaluate to sink values and which may have free variables that can be bound to sink values. (More ambitious expression DSLs may have type systems, may have the ability to compile to various specific platforms, may have the ability to be traversed, etc.)

- - If the nameless freestanding DSL-expression macro for this DSL doesn't find its . that's an error. (It's unclear what kind of expression we would need to write using a backslash. Perhaps numeric literal syntaxes?)

- - If the nameless bounded DSL-expression macro for this DSL doesn't find its . it behaves as though it found it anyway.

- Sink binding sites: Sets of variables that should be lexically bound to an incoming sink value, along with the source location information to blame for each variable in case we need to cause an error relating to duplicate variables. (More ambitious binding site DSLs may have binding sites that have type annotations or that apply patterns to destructure their values.)

- - If the nameless freestanding DSL-expression macro for this DSL doesn't find its . it behaves as though it found it anyway. (Bracketless syntaxes are precious for binding sites, since binding syntaxes are often designed with the expectation their binding sites will be consise enough to squeeze in on the same line as several other things, and brackets tend to push both themselves and the following expressions onto individual lines. One named macro would likely be the most prominent of all here, namely a macro that binds its input to zero variables (ignoring it), but it seems like the syntax \- or \unused is plenty concise, so we don't need to go quite as far as reserving \ for that exclusive purpose.)

- - If the nameless bounded DSL-expression macro for this DSL doesn't find its . it behaves as though it found it anyway. (There is likely going to be a most prominent operation, namely taking the disjoint union of multiple binding sites. However, that's not a call-like operation, so the indentation would work out better if it were written with an explicit operator name like (conflate a b) rather than (a b).)

- Declarations in a lexical unit: Functions that take an "interface" familiarity ticket and an "implementation" familiarity ticket and return an extfx computation that spends its "interface" ticket to describe what things the current lexical unit defines, what things it exports, and what struct export conditions it determines, then eventually spends its "interface" ticket to describe what directive expressions can be used to compute those definitions.

- - If the nameless freestanding DSL-expression macro for this DSL doesn't find its . that's an error. (It's unclear what other behavior we might like here.)

- - If the nameless bounded DSL-expression macro for this DSL doesn't find its . it behaves as though it found it anyway.

- Fragments of whitespace-normalizable interpolated string literals.

- - If the nameless freestanding DSL-expression macro for this DSL doesn't find its . it behaves as though it found it anyway. (In string literals, various \ syntaxes are important as escape sequences.)

- - If the nameless bounded DSL-expression macro for this DSL doesn't find its . it reads any number of whitespace-normalizing string fragments and surrounds them with the current opening delimiter and the current closing delimiter (imitating what would have happened if the delimiters were treated as miscellaneous text rather than a bounded macro call).

- - The operation that reads an optional fragment of a whitespace-normalizable interpolated string literal is different. When it finds a nonempty span of Unicode whitespace, it creates a fragment that carries that whitespace with the explicit knowledge that it is whitespace that might be normalized. When it finds a nonempty span of any non-Unicode-whitespace text other than \ [ ] ( ) and / it creates a fragment that carries that non-whitespace text. When it finds \' [' (' or /' it invokes the appropriate comment macro and finds a whitespace fragment containing the text that was consumed this way. When it finds \@ [@ (@ or /@ it invokes the appropriate identifier macro, then invokes the glossary DSL-expression macro for this macro DSL and finds the fragment resulting from that. When it encounters ] or ) or end-of-file, it finds no fragment (not even an empty one).

- - - TODO: Some sequences like [' and (' or even ['. and ('. seem like they'll be common in quoted non-Cene code. See if we should redesign these to be [.' and (.' or something like that. This might involve redesigning our other DSLs as well.

- - - TODO: See if we're right to think of a \' [' (' or /' comment as a form of "whitespace" here. Perhaps these cases should find empty fragments rather than whitespace fragments, or perhaps they should find a distinct kind of "comment" fragment so the user may normalize comments at their own discretion.

- - - TODO: If we're going to escape unmatched occurrences of [ ] ( ) in strings as \< \> \{ \} again, that means we're not going to be writing the \< and \{ delimiters at the start of a line; the \ gets in the way. Is that okay? Actually, it's probably great. Since these are unmatched delimiters, we don't want them to appear unfettered at the start of a line where we might make the mistake of thinking they need to be closed the usual way.

- - - TODO: (multiple paragraphs) {

In order for nested occurrences of string literals to be suppressed (treated as string contents so we can more easily generate Cene code that contains string literals), we'll need to somehow pass a different nesting depth to different macro calls of the DSL. How should we do that?

In a general sense, this is precisely what we started the Punctaffy project to explore (after making a bit of a ball of mud exploring it in Cene for JavaScript). There was a lot of complexity to work out.

One viable approach we found in Punctaffy was to pass around hyperstacks. If we do pass around hyperstacks of some sort (in this case perhaps a low-dimensional stack with such simple stack frames that it merely represents a nesting depth), then how would we pass them around?

One option would be to treat the hyperstack as an attribute carried on a macro DSL object itself; in some sense we have a different DSL altogether at each depth. (This means we would have an explicit first-class macro DSL object we pass around during macroexpansion, which will probably be true if only so that we can reuse some of the code for the behaviors that are common to virtually every macro DSL.)

On the other hand, hypersnippet delimiters are an issue that will tend to have an impact on every single macro DSL, so we'll likely want to make them a fundamental part of the calling convention. After all, if two macro DSLs start to use different hypernest brackets, they'll have trouble respecting each other's brackets. If nothing else, we should at least have them all independently look for the kind of < > and = delimiters we describe in NOTE HYPERSNIPPETS.

Maybe we could carry the hyperstack on the _text input stream_. That way in some places where we use `extfx-read-fault` to read a 0-dimensional source location region, we can read a 1-dimensional source location region instead, and the obligation to complete the region can be fulfilled by the protocol of that 1-dimensional `extfx-read-fault` variant. And in places where we set up a delimiter that we expect to see later, we can use a similar 1-dimensional operation that reads using an opening and a closing textpat and discharges the obligation to match the closing textpat as part of its protocol. Making a local change to the string nesting depth would be just another of these operations. Hmm, yes, the idea of reading hypersnippet-shaped patterns from a stream seems like a very nice and structured way to manage the obligations.

The complexity of any of these options might intimidate Cene newcomers. In the short term, the best course of action is probably to use string syntaxes that don't gracefully nest.

}

- Someday, patterns for pattern-matching.

- - If the nameless freestanding DSL-expression macro for this DSL doesn't find its . that's an error. (It's unclear what other behavior we might like here.)

- - If the nameless bounded DSL-expression macro for this DSL doesn't find its . it behaves as though it found it anyway.

- Hypothetically, hypersnippet dimension numerals: If we follow the plans we're describing around hypersnippets (NOTE HYPERSNIPPETS), then at some point we need a DSL for numerals that can be used to specify a delimiter's degree.

- - If the nameless freestanding DSL-expression macro for this DSL doesn't find its . that's an error. (It's unclear what kind of numeral we would need to write using a backslash. Perhaps numerals written in different bases?)

- - If the nameless bounded DSL-expression macro for this DSL doesn't find its . that's an error. (It's unclear what other behavior we might like here. It's unclear there would even be one useful behavior, let alone a variety.)

- - The operation that reads an optional numeral is different. When it finds a nonempty span of decimal digits, it converts that to a nonnegative integer using decimal notation.

- Hypothetically, structured code syntax of various forms, such as s-expressions. In particular, if we develop a variant of Cene that has a read phase that matches all the brackets first before performing more macroexpansion, then we can have more hygienic quotation operations: It won't be possible for the code to redefine what a closing bracket means, so the quotation operation will know how to interpret the closing bracket that ends the quotation without having to check whether the code it's quoting contains such a redefinition. And if we develop that variant of Cene and have two variants, then programmers using the reader-macro-style variant might like to write programs that generate code for that s-expression-macro-style variant.

- - The operation that reads an optional piece of structured code is different. When the usual one would invoke various macros, this one instead reads the arguments itself, assuming a fixed calling convention. It may at certain points transition to a DSL for escape sequences or a DSL for representing less-structured code (especially for representing the contents of string literals).

- - Effectively there are no actual macros here, except perhaps a system of escape sequence macros. As such, the glossary DSL-expression macro, the nameless freestanding DSL-expression macro, and the nameless bounded DSL-expression macro don't exist, much less the unceremonious and named macros they would usually call out to.

- Hypothetically, dexed-returning sink expressions, where most struct constructors instead take dexed arguments and create dexed structs. This macro DSL has behavior similar to the sink expression macro DSL, but it doesn't have all the same macros.

- Hypothetically, mobile-returning sink expressions, where lexical-unit-level definitions of struct constructors and functions can be called in ways that take mobile arguments and create mobile results. This macro DSL has behavior similar to the sink expression macro DSL, but it doesn't have all the same macros.



NOTE HYPERSNIPPETS: In the future, we might use bounded macro syntaxes with < > and = sigils to represent hypersnippet-bounded macro calls. The < would concisely denote the opening of a hypersnippet shape (possibly represented as a hypernest bump), the > would concisely denote one of the closing holes of such a shape, and the = would be a catch-all for less concise situations which are distinguished by identifier names. For instance, we might use = and a certain identifier to close several concentric shapes all at once. Note that by the time we support this, our calling convention for macros may change to have a stack of contexts, so that a span of whitespace that encounters a closing bracket can resume a hypersnippet-shaped comment already in progress. Hypersnippets are a concept explored in the Punctaffy project.
