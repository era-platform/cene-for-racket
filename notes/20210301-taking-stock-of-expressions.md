This is the current set of expressions implemented in Cene (which we can find in the code by looking for `prop:cexpr`):

```
var
let

reified

located

construct
call-fault
call
opaque-fn-fault
opaque-fn
dex-struct
cline-struct
merge-struct
fuse-struct
case
```

Quite a number of those revolve around the various ways to introduce and eliminate structs. Structs are leading a double life as both a way to represent functions and as a way to represent records. Every feature they have is in service of their role as functions, because they let us require some things of a function that traditional lambdas aren't transparent enough to allow. Treating a function as a struct this way is varying degrees of "unsafe" since the client may observe information that they couldn't have learned by calling the function. This unsafety is ironic, since the reason Cene needs functions that are transparent in this way is so that it can ensure that all code that works with modules or declarative DSLs is invariant with respect to the order those modules or declarations are processed in.

These are the levels of safety if we regard a struct as a function, as a record, or as something in between (a "coordination error check device," less intentionally transparent than a struct but less featureful than a function):

```
       safety level when regarding a struct as a function
?***** good for opaque functions
  **** good for opaque functions which may need to be coordinated in ways that need to be checked for mismatch errors
   *** good for opaque functions with backward-compatibility equality guarantees to keep
    ** good for opaque functions with the need for opportunistic AOT optimizations, caches, safe-for-space abstractions, or friendly error messages
     * good only for records which may not even be used as functions at all

       safety level when regarding a struct as a coordination error check device
?***** extraneous and meaningless for coordination error check devices
  **** good for coordination error check devices
   *** good for coordination error check devices with backward-compatibility equality guarantees to keep
    ** good for coordination error check devices with the need for caches or friendly error messages
     * good only for records which may not even be used as coordination error check devices at all

       safety level when regarding a struct as a record
?***** extraneous and meaningless for records
  **** good for records
   *** good for records
    ** good for records
     * good for records

?***** call-fault
?***** call
?***** opaque-fn-fault
?***** opaque-fn
?***** fuse-opaque-fn (a function rather than an expression)
  **** def-struct (a lexical unit declaration rather than an expression)
  **** construct
  **** assertdex-struct (not in Cene (yet?); this would be like a dex, but treating inequality as an error)
   *** dex-struct
   *** cline-struct
   *** merge-struct
   *** fuse-struct
   *** case
```

Suppose we were to split up this design so that non-function records are a separate type. Since none of these operations is in the one-star safety zone, they're likely to all stick around in some form for functions.

We can still simplify the interface for functions, but not by much: We can change all the record-like operations so that there's only a single record field involved. If we do that, multi-field functions can still be simulated by storing a multi-field record in a function's single field.

Meanwhile, one of the conundrums we're currently having with structs is that they're not quite the expression problem solution we originally had in mind. Potentially, we could treat `call`/`call-fault` as just one of many interfaces a struct could have an implementation for. But... if a *user* of Cene comes up with a new interface like that, they can only compile their program if all structs in the program have implementations for all the interfaces.

So, in the long run, what we probably want to do is let users coin new struct-like types that support specific sets of interfaces. The original Cene structs would be dedicated to supporting `call`/`call-fault`, and when a program contains an expression that constructs those structs, it only needs `call`/`call-fault` to be implemented. If the user creates, say, a UI widget interface, then the only construction expressions that require a UI widget implementation to exist are the UI widget construction expressions.

Another conundrum on our minds has been getting the names generated by most Cene programs to be more predictable (less reliant on unique names). This would cache macroexpansion results in a fine-grained way without the cache constantly being invalidated by edits to the code. To make names more predictable, it would probably help to be able to take names apart and re-normalize them programmatically as we go along.

Considering that, we might want names to have a set of operations for name-structs similar to our operations for function-structs. Instead of `call`/`call-fault`, the high-level operation would be `dex-name`. There would be a separate `dex-name-struct` for expressing a dex that only matches a name with a known name-struct constructor:

```
       safety level when regarding a name-struct as a name
?***** good for opaque names
  **** good for opaque names which may need to be coordinated in ways that need to be checked for mismatch errors
   *** good for opaque names with backward-compatibility equality guarantees to keep
    ** good for opaque names with the need for caches, safe-for-space abstractions, or friendly error messages
     * good only for records which may not even be used as names at all

       safety level when regarding a name-struct as a dexable coordination error check device
?***** good for coordination error check devices which need to be dexable, i.e., need to be compared with others for equality
  **** good for coordination error check devices
   *** good for coordination error check devices with backward-compatibility equality guarantees to keep
    ** good for coordination error check devices with the need for caches or friendly error messages
     * good only for records which may not even be used as coordination error check devices at all

       safety level when regarding a name-struct as a dexable record
?***** good for records which need to be dexable, i.e., need to be compared with others for equality
  **** good for records
   *** good for records
    ** good for records
     * good for records

?***** dex-name (a function rather than an expression)
  **** def-name-struct (not in Cene (yet?); a lexical unit declaration rather than an expression)
  **** name-construct (not in Cene (yet?))
  **** assertdex-name-struct (not in Cene (yet?); this would be like a dex, but treating inequality as an error)
   *** dex-name-struct (not in Cene (yet?))
   *** cline-name-struct (not in Cene (yet?))
   *** merge-name-struct (not in Cene (yet?))
   *** fuse-name-struct (not in Cene (yet?))
   *** name-struct-case (not in Cene (yet?))
```

Of course, coordination error-checking is probably the primary use of a name, so there isn't much of a difference between four stars and five stars in this case. However, the primary way to compare names would be `dex-name`, not these finer-grained mechanisms. Similarly, the primary way to construct names would still be `getfx-name-of` and other built-in name constructors/procurers. By designating these finer-grained operations as more unsafe, we can keep the analogy to functions going, possibly leading to fewer surprises for users and more obvious opportunities for abstraction.

Note that we don't quite have a seamless opportunity for abstraction here, because `name-construct` would need to require the field value(s) to be dexed values.

Another conundrum we've been considering in Cene is how to keep the identities of dexes, clines, merges, and fuses backwards-compatible. So we might want to be able to create `def-dex-struct`, `def-cline-struct`, etc., with the custom behavior specified according to mechanisms similar to `dex-by-own-method`, `cline-by-own-method`, etc.

Of course, there may be a bit of a loop to tie off here, since names, dexes, clines, merges, and fuses are implicated in the interfaces of *all* these things (via `dex-_____-struct`, `cline-_____-struct`, etc., as well as `getfx-name-of` applied to `dex-_____-struct`). Even if we extend the same abstraction to all of these things, we might still need to special-case them.
