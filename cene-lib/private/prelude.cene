\= prelude.cene
\=
\= Cene built-ins that can be defined in terms of a (mostly) smaller
\= set of built-ins.

\=   Copyright 2019 The Era Authors
\=
\=   Licensed under the Apache License, Version 2.0 (the "License");
\=   you may not use this file except in compliance with the License.
\=   You may obtain a copy of the License at
\=
\=       http://www.apache.org/licenses/LICENSE-2.0
\=
\=   Unless required by applicable law or agreed to in writing,
\=   software distributed under the License is distributed on an
\=   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
\=   either express or implied. See the License for the specific
\=   language governing permissions and limitations under the License.


\= TODO: Finish implementing `extfx-read-bounded-exprs`.

\= TODO: Work up to defining `defn` and `def-macro`. In order to do
\= that, we've been porting things to Cene local variables that we've
\= already implemented on the Racket side. Once we use these local
\= variables to define `defn` and `def-macro`, we'll want to repeat a
\= number of these ported definitions in `defn` form as well. It may
\= be possible to reuse the definitions rather than copying and
\= pasting, but let's regard copying and pasting as a serious option
\= here.

\= TODO: Make sure we make most of the things we define in the prelude
\= visible to user-supplied Cene code by using
\= `extfx-add-init-package-step`.

(directive /fn root-unique-name root-qualify
  (let err
    (fn-blame bl str
      (follow-heart/clamor-err bl str))
  /let self-app
    (fn-blame bl f
      (c-blame bl f f))
  /let fix
    (c self-app /fn make-fix
    /fn-blame bl-f f
      (let fix (c make-fix make-fix)
      /fn-blame bl-arg arg
        (c-blame bl-arg (c-blame bl-f f /c-blame bl-f fix f) arg)))
  /let maybe-bind
    \= TODO: See if we'll use this.
    \= TODO: See if this should verify its output is a maybe as well.
    (fn-blame bl m then
      (case m nothing (nothing)
      /cast m just s
        [c-blame bl err /str-prim:Expected m to be a nothing or a just]
      /c-blame bl then s))
  /let not
    (fn-blame bl b
      (case b yep b (nope b)
      /case b nope b (yep b)
        [c-blame bl err /str-prim:Expected b to be a yep or a nope]))
  /let and
    \= NOTE: We could also call this `either-bind`.
    \= TODO: See if this should verify its output is an either as
    \= well.
    (fn-blame bl a get-b
      (case a nope s (nope s)
      /cast a yep s
        [c-blame bl err /str-prim:Expected a to be a yep or a nope]
      /c-blame bl get-b s))
  /let list-length
    (c fix /fn list-length
    /fn-blame bl xs
      (case xs nil (int-zero)
      /cast xs cons x xs
        [c-blame bl err /str-prim:Expected xs to be a cons list]
      /pure-run-getfx /getfx-call-fuse (fuse-int-by-plus) (int-one)
        (c-blame bl list-length xs)))
  /let is-name
    (fn x
      (pure-run-getfx/getfx-is-in-dex (dex-name) x))
  /let is-dex
    (fn x
      (pure-run-getfx/getfx-is-in-dex (dex-dex) x))
  /let is-cline
    (fn x
      (pure-run-getfx/getfx-is-in-dex (dex-cline) x))
  /let pure-compare-by-cline-force
    (fn-blame bl cline a b
      (cast (c is-cline cline) yep -
        [c-blame bl err /str-prim:Expected cline to be a cline]
      /cast (pure-run-getfx/getfx-compare-by-cline cline a b)
        just result
        [c-blame bl err /str-prim:Expected a and b to be elements of the given cline]
        result))
  /let pure-is-lt
    (fn-blame bl cline a b
      (case (c-blame bl pure-compare-by-cline-force cline a b)
        ordering-lt
        (yep/nil)
        (nope/nil)))
  /let pure-is-gt
    (fn-blame bl cline a b
      (c-blame bl pure-is-lt cline b a))
  /let pure-is-lte
    (fn-blame bl cline a b
      (c not /c-blame bl pure-is-gt cline a b))
  /let pure-is-gte
    (fn-blame bl cline a b
      (c-blame bl pure-is-lte cline b a))
  /let getfx-map
    (fn-blame bl effects func
      (cast (is-getfx effects) yep -
        [c-blame bl err /str-prim:Expected effects to be a getfx value]
      /getfx-bind effects /fn intermediate
      /getfx-done /c-blame bl func intermediate))
  /let getfx-in-fuse
    \= TODO: See if this is really the way we want to implement this.
    \= What if calling the fuse is expensive?
    (fn fuse x
      (c getfx-map (getfx-call-fuse fuse x x) /fn maybe-fused
        (case maybe-fused just -
          (yep/nil)
          (nope/nil))))
  /let is-extfx
    (fn x
      (pure-run-getfx /c getfx-in-fuse (fuse-extfx) x))
  /let is-int
    (fn x
      (pure-run-getfx/getfx-is-in-dex (dex-int) x))
  /let is-nat
    (fn x
      (c and (c is-int x) /fn -
      /c pure-is-lte (cline-int) (int-zero) x))
  /let nat-to-maybe
    (fn-blame bl n
      (cast (c is-nat n) yep -
        [c-blame bl err /str-prim:Expected n to be a natural number]
      /cast (c pure-is-lt (cline-int) (int-zero) n) yep - (nothing)
      /just /int-minus n /int-one))
  /let name-of-string
    (fn-blame bl string
      (cast (pure-run-getfx/getfx-name-of (dex-string) string)
        just result
        [c-blame bl err /str-prim:Expected string to be a string]
        result))
  /let give3
    (fn-blame bl a1 a2 a3 f
      (c-blame bl f a1 a2 a3))
  /let loop3
    (fn-blame bl s1 s2 s3 body
      (c-blame bl give3 s1 s2 s3 /c-blame bl fix body))
  /let unique-name-for-split-first
    (authorized-name-get-name/authorized-name-subname
      [c name-of-string /str-prim:first]
      root-unique-name)
  /let unique-name-for-split-rest
    (authorized-name-get-name/authorized-name-subname
      [c name-of-string /str-prim:rest]
      root-unique-name)
  /let extfx-claim-and-split
    (fn-blame bl unique-name n then
      (cast (is-authorized-name unique-name) yep -
        [c-blame bl err /str-prim:Expected unique-name to be an authorized name]
      /cast (c is-nat n) yep -
        [c-blame bl err /str-prim:Expected n to be a natural number]
      /extfx-claim unique-name /fn -
      /c loop3 n unique-name (nil) /fn next n next-name names
        (cast (c nat-to-maybe n) just n (c-blame bl then names)
        /let first
          (authorized-name-subname unique-name-for-split-first
            next-name)
        /let rest
          (authorized-name-subname unique-name-for-split-rest
            next-name)
        /c next n rest /cons first names)))
  /let extfx-claim-freshen
    (fn-blame bl unique-name then
      (cast (is-authorized-name unique-name) yep -
        [c-blame bl err /str-prim:Expected unique-name to be an authorized name]
      /c extfx-claim-and-split unique-name (int-one)
      /fn unique-names
      /cast unique-names cons unique-name -
        [c err /str-prim:Internal error: Expected the list resulting from extfx-claim-and-split to be a list of the requested length]
      /c-blame bl then unique-name))
  
  \= This reads expressions until it gets to a closing bracket.
  /let extfx-read-bounded-exprs
    (fn-blame bl-implicit
      bl-explicit unique-name qualify text-input-stream then
      \= TODO: Implement this.
      (nil))
  
  \= This reads expressions until it gets to a closing bracket, and it
  \= verifies that there are precisely `n` of them.
  /let extfx-read-bounded-specific-number-of-exprs
    (fn-blame bl-implicit
      bl-explicit unique-name qualify text-input-stream n then
      
      (cast (is-blame bl-explicit) yep -
        [c-blame bl-implicit err /str-prim:Expected bl-explicit to be a blame value]
      /cast (is-authorized-name unique-name) yep -
        [c-blame bl-implicit err /str-prim:Expected unique-name to be an authorized name]
      /cast (is-text-input-stream text-input-stream) yep -
        [c-blame bl-implicit err /str-prim:Expected text-input-stream to be a text input stream]
      /cast (c is-nat n) yep -
        [c-blame bl-implicit err /str-prim:Expected n to be a natural number]
      /c extfx-read-bounded-exprs
        bl-explicit unique-name qualify text-input-stream
      /fn unique-name qualify text-input-stream exprs
      /let actual-n (c list-length exprs)
      /case (c pure-is-lt (cline-int) n actual-n) yep -
        \= TODO FAULT: Make this `bl-explicit` more specific.
        [c-blame bl-explicit err /str-prim:Encountered too many expressions]
      /case (c pure-is-lt (cline-int) actual-n n) yep -
        \= TODO FAULT: Make this `bl-explicit` more specific.
        [c-blame bl-explicit err /str-prim:Expected another expression]
      /let effects
        (c-blame bl-implicit then
          unique-name qualify text-input-stream exprs)
      /cast (c is-extfx effects) yep -
        [c-blame bl-implicit err /str-prim:Expected the return value of an extfx-read-bounded-specific-number-of-exprs callback to be an extfx effectful computation]
        effects))
  
  /let extfx-def-fallibly-dexed-value-for-lang-impl
    (fn-blame bl unique-name target-name dex value
      (cast (is-authorized-name unique-name) yep -
        [c-blame bl err /str-prim:Expected unique-name to be an authorized name]
      /cast (is-authorized-name target-name) yep -
        [c-blame bl err /str-prim:Expected target-name to be an authorized name]
      /cast (c is-dex dex) yep -
        [c-blame bl err /str-prim:Expected dex to be a dex]
      /extfx-claim unique-name /fn -
      /extfx-put target-name dex value))
  /let extfx-def-fallibly-dexed-value-for-package
    (fn-blame bl unique-name target-name dex value
      (cast (is-authorized-name unique-name) yep -
        [c-blame bl err /str-prim:Expected unique-name to be an authorized name]
      /cast (c is-name target-name) yep -
        [c-blame bl err /str-prim:Expected target-name to be a name]
      /cast (c is-dex dex) yep -
        [c-blame bl err /str-prim:Expected dex to be a dex]
      /c extfx-claim-freshen unique-name /fn unique-name
      /extfx-add-init-package-step unique-name
      /fn unique-name qualify-for-package
        (extfx-claim unique-name /fn -
        /extfx-put (c qualify-for-package target-name) dex value)))
  /let extfx-def-value-for-lang-impl
    (fn-blame bl unique-name target-name value
      (cast (is-authorized-name unique-name) yep -
        [c-blame bl err /str-prim:Expected unique-name to be an authorized name]
      /cast (is-authorized-name target-name) yep -
        [c-blame bl err /str-prim:Expected target-name to be an authorized name]
      /c extfx-claim-freshen unique-name /fn unique-name
      /c extfx-def-fallibly-dexed-value-for-lang-impl
        unique-name target-name (dex-give-up) value))
  /let extfx-def-value-for-package
    (fn-blame bl unique-name target-name value
      (cast (is-authorized-name unique-name) yep -
        [c-blame bl err /str-prim:Expected unique-name to be an authorized name]
      /cast (c is-name target-name) yep -
        [c-blame bl err /str-prim:Expected target-name to be a name]
      /c extfx-claim-freshen unique-name /fn unique-name
      /c extfx-def-fallibly-dexed-value-for-package
        unique-name target-name (dex-give-up) value))
  /let macro-impl
    (fn-blame bl-body body
      (fn-blame bl-macro
        unique-name qualify text-input-stream output-stream then
        
        (cast (is-authorized-name unique-name) yep -
          [c-blame bl-macro err /str-prim:Expected unique-name to be an authorized name]
        /cast (is-text-input-stream text-input-stream) yep -
          [c-blame bl-macro err /str-prim:Expected text-input-stream to be a text input stream]
        /cast (is-expr-sequence-output-stream output-stream) yep -
          [c-blame bl-macro err /str-prim:Expected output-stream to be an expression sequence output stream]
        /c body
          bl-macro unique-name qualify text-input-stream output-stream
        /fn unique-name qualify text-input-stream output-stream
        /let effects
          (c-blame bl-macro then
            unique-name qualify text-input-stream output-stream)
        /cast (c is-extfx effects) yep -
          [c-blame bl-macro err /str-prim:Expected the return value of a macro's callback to be an extfx effectful computation]
          effects)))
  
  \= This creates a macro implementation function that reads a form
  \= body of precisely `n-args` cexprs, then writes a single cexpr
  \= computed from those using `body`.
  /let macro-impl-specific-number-of-args
    (fn-blame bl-body n-args body
      (cast (c is-nat n-args) yep -
        [c-blame bl-body err /str-prim:Expected n-args to be a natural number]
      /c macro-impl
      /fn
        bl-macro unique-name qualify text-input-stream output-stream
        then
        
        (c extfx-read-bounded-specific-number-of-exprs
          bl-macro unique-name qualify text-input-stream n-args
        /fn unique-name qualify text-input-stream args
        /extfx-expr-write output-stream (c-blame bl-body body args)
        /fn output-stream
        /let effects
          (c-blame bl-macro then
            unique-name qualify text-input-stream output-stream)
        /cast (c is-extfx effects) yep -
          [c-blame bl-macro err /str-prim:Expected the return value of a macro-impl-specific-number-of-args callback to be an extfx effectful computation]
          effects)))
  
  /extfx-noop))
