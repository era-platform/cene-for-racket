\= prelude.cene
\=
\= Cene built-ins that can be defined in terms of a (mostly) smaller
\= set of built-ins.

\=   Copyright 2019 The Era Authors
\=
\=   Licensed under the Apache License, Version 2.0 (the "License");
\=   you may not use this file except in compliance with the License.
\=   You may obtain a copy of the License at
\=
\=       http://www.apache.org/licenses/LICENSE-2.0
\=
\=   Unless required by applicable law or agreed to in writing,
\=   software distributed under the License is distributed on an
\=   "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
\=   either express or implied. See the License for the specific
\=   language governing permissions and limitations under the License.


\= TODO SCRATCH: We're currently "commenting out" a large portion of
\= this file by putting it in a separate file,
\= prelude-scratch-work.cene. Gradually uncomment this code as we
\= verify that it doesn't cause errors. The place it should appear is
\= marked by another TODO SCRATCH comment.

\= TODO: Work up to defining `defn` and `def-macro`. In order to do
\= that, we've been porting things to Cene local variables that we've
\= already implemented on the Racket side. Once we use these local
\= variables to define `defn` and `def-macro`, we'll want to repeat a
\= number of these ported definitions in `defn` form as well. It may
\= be possible to reuse the definitions rather than copying and
\= pasting, but let's regard copying and pasting as a serious option
\= here.

\= TODO: Make sure we make most of the things we define in the prelude
\= visible to user-supplied Cene code by using
\= `effects-add-init-package-step`.

(directive /fn root-unique-name root-qualify
  (let err
    (fn-blame bl str
      (follow-heart/clamor-err bl str))
  /let maybe-bind
    \= TODO: See if we'll use this.
    \= TODO: See if this should verify its output is a maybe as well.
    (fn-blame bl m then
      (case m nothing (nothing)
      /cast m just s
        [c-blame bl err /str-prim Expected m to be a nothing or a just]
      /c-blame bl then s))
  /let not
    (fn-blame bl b
      (case b yep b (nope b)
      /case b nope b (yep b)
        [c-blame bl err /str-prim Expected b to be a yep or a nope]))
  /let and
    \= NOTE: We could also call this `either-bind`.
    \= TODO: See if this should verify its output is an either as
    \= well.
    (fn-blame bl a get-b
      (case a nope s (nope s)
      /cast a yep s
        [c-blame bl err /str-prim Expected a to be a yep or a nope]
      /c-blame bl get-b s))
  /let is-dex
    (fn x
      (in-dex (dex-dex) x))
  /let is-cline
    (fn x
      (in-dex (dex-cline) x))
  \= TODO SCRATCH: Once it doesn't cause errors, put the code from
  \= prelude-scratch-work.cene here.
  /effects-noop))
